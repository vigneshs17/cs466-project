# -*- coding: utf-8 -*-
"""twoSidedMatchingApproach.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1W-SHKMjtBlyw6NHTuBMqN55qKbZPDPMs
"""

# Declaring the variables used in the simulation

ck = numberOfCpuCycles = [] # Ck
k = numberOfUsers = None # k
m = numberOfAp = 3 # m = 3
rk= totalBits = [] # Rk
lkm = offloadedBits = [[]] # 2D list lkm
fk = localCpuFrequency = [] # Fk
fkm = apCpuFrequency = [[]] #fkm
fm = apCpuEachSlot = [] # Fm

xkm = ifOffloaded = [[]] # 2D list xkm
txl = totalLatencyPerUser = [] # Txl
akm = alpha = 0.2 # akm out-in ratio
rukm =uplinkTransmissionRate = [[]] # rukm
rdkm = downlinkTransmissionRate = [[]] # rdkm

tkm = minimumOffloadingTIme = [[]] # tkm
user_order = []
ap_order = []

# Function to find the ideal bits to be offlaoded for each AP for each user 

def compute_bits_to_offload(k):
  for i in range(0,k):
    lkm.append([])
    tkm.append([])
    for j in range(0,3):
      temp = fk[i] / rukm[i][j] + ck[i] * fk[i] / fkm[i][j]
      temp += ck[i] + akm * fk[i] / rdkm[i][j]
      lkm[i].append((rk[i] * ck[i]) / temp)
      tkm[i].append((ck[i] / fk[i]) * (rk[i] - lkm[i][j]))
      print(lkm[i][j])

#Function to assign values to the variables.  Done according to the range specified in the paper

import numpy as np

akm = 0.2
def assign(k):
  m = 3
  for i in range(0,m):
    fm.append(np.random.randint(50,100)) # Mhz/Slot

  for i in range(0,k):
    fk.append(np.random.randint(400,500))  #MHz
    ck.append(np.random.randint(500,1500)) #cycles/bit
    rk.append(np.random.randint(50,80))  # kb
    fkm.append([])
    rukm.append([])
    rdkm.append([])
    for j in range(0,m):
      fkm[i].append(np.random.randint(3000,15000)) # Ghz
      rukm[i].append(np.random.randint(1,3)) # Mbp/s
      rdkm[i].append(np.random.randint(2,5)) #Mbp/s

assign(30)

compute_bits_to_offload(30)

print(len(lkm))

for i in range(0,30):
  for j in range(0,3):
    print(lkm[i][j])

# Algorithm that computes all operations locally
# Used as a comparision

def local_compute(k):
  time = 0
  for i in range(0,k):
    time += rk[i] * ck[i] / fk[i]
  avg_latency = time/k
  return avg_latency

#Function to create user prefarence Profile 
#Finds the AP prefarence value of each user and sorts them in increasing order

user_profile = [[]*30]
def preference_user(k):
  for i in range(k):
    for j in range(3):
      user_profile[i].append([tkm[i][j], j])
  
  for i in range(k):
    user_profile.sort()

#Function to create AP prefarence Profile 
#Finds the user prefarence value of each AP and sorts them in decreasing order

ap_profile = [[]*3]
def preference_ap(k):
  for i in range(3):
    for j in range(k):
      ap_profile[i].append([lkm[j][i] * ck[j], j])
  
  for i in range(3):
    ap_profile.sort(reverse = True)

fresm = fm

#Algorithm for A Two-Sided Matching Approach for Distributed Edge Computation Offloading
# Returns the user - AP mapping for offfloading

def two_sided_matching(pk,pm):
  match = [[False for _ in range(3)] for _ in range(30)]
  for i in range(k):
    user = i
    for _, ap in pk[i]:
      offload = lkm[user][ap]
      computationCapacity = offload*ck[user]
      if fm[ap] >= computationCapacity:
        fm[ap] -= computationCapacity
        match[user][ap] = True
      else:
        order = dict()
        for o in range(k):
          order[ap_profile[ap][1]] = 0
        order = sorted(order, key=lambda x : (x[1], x[0]))
        order = dict()
        for u,v in order:
          order[u] = v
        res = 0
        for i in range(k):
          if match[i][ap] and order[i] < order[user]:
            res += lkm[i][ap]
            match[i][ap] = False
        
        if fkm[ap] + res >= computationCapacity:
          match[user][ap] = True
    return match

# Function to each latency in two sided matching approch form the matching function

def two_sided_latency(k):
  xkm = two_sided_matching(user_profile, ap_profile)
  total_time = 0
  for i in range(k):
    for j in range(3):
      if xkm[i][j]:
        total_time += tkm[i][j]
  
  avg_latency = total_time/k
  return avg_latency

# Function to plot the results 
#Plotting our results

import matplotlib.pyplot as plt

users = [10,15,20,25,30]
local_latency = []
for i in users:
  local_latency.append(local_compute(i))

two_sided_latency = []

for i in users:
  two_sided_latency.append(two_sided_latency(i))

plt.plot(users,local_latency)
plt.plot(users,two_sided_latency)

plt.xlabel('Number of Users')
plt.ylabel('Average latency(ms)')
plt.title('Influence of the number of users')
 
plt.show()

